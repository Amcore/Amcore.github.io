(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{77:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"content"},[a("h3",{attrs:{id:"浏览器架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器架构","aria-hidden":"true"}},[t._v("#")]),t._v(" 浏览器架构")]),a("ul",[a("li",[t._v("用户界面")]),a("li",[t._v("主进程")]),a("li",[t._v("内核\n"),a("ul",[a("li",[t._v("渲染引擎")]),a("li",[t._v("JS引擎\n"),a("ul",[a("li",[t._v("执行栈")])])]),a("li",[t._v("事件触发线程\n"),a("ul",[a("li",[t._v("消息队列\n"),a("ul",[a("li",[t._v("微任务")]),a("li",[t._v("微任务")])])]),a("li",[t._v("网络异步线程")]),a("li",[t._v("定时器线程")])])])])])]),a("h3",{attrs:{id:"跨标签页通讯"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跨标签页通讯","aria-hidden":"true"}},[t._v("#")]),t._v(" 跨标签页通讯")]),a("p",[t._v("不同标签页间的通讯，本质原理就是去运用一些可以 共享的中间介质，因此比较常用的有以下方法:")]),a("ul",[a("li",[t._v("通过父页面"),a("code",[t._v("window.open()")]),t._v("和子页面postMessage\n"),a("ul",[a("li",[t._v("异步下，通过"),a("code",[t._v("window.open('about: blank')")]),t._v("与监听"),a("code",[t._v("window.onstorage")])])])]),a("li",[t._v("设置同域下共享的"),a("code",[t._v("localStroage")]),t._v("与监听"),a("code",[t._v("window.onstorage")]),a("ul",[a("li",[t._v("重复写入相同的值无法触发")]),a("li",[t._v("会受到浏览器隐私模式等的限制")])])]),a("li",[t._v("设置共享"),a("code",[t._v("cookie")]),t._v("与不断轮询脏检查("),a("code",[t._v("setInterval")]),t._v(")")]),a("li",[t._v("借助服务端或者中间层实现")])]),a("h3",{attrs:{id:"浏览器下事件循环-event-loop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器下事件循环-event-loop","aria-hidden":"true"}},[t._v("#")]),t._v(" 浏览器下事件循环(Event Loop)")]),a("p",[t._v("事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表")]),a("ul",[a("li",[t._v("微任务 "),a("code",[t._v("microtask(jobs): promise / ajax / Object.observe(该方法已废弃)")])]),a("li",[t._v("宏任务 "),a("code",[t._v("macrotask(task): setTimout / script / IO / UI Rendering")])])]),a("h3",{attrs:{id:"从输入-url-到展示的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从输入-url-到展示的过程","aria-hidden":"true"}},[t._v("#")]),t._v(" 从输入 url 到展示的过程")]),a("ul",[a("li",[t._v("DNS 解析")]),a("li",[t._v("TCP 三次握手")]),a("li",[t._v("发送请求，分析 url，设置请求报文(头，主体)")]),a("li",[t._v("服务器返回请求的文件 (html)")]),a("li",[t._v("浏览器渲染\n"),a("ul",[a("li",[t._v("HTML parser --\x3e DOM Tree\n"),a("ul",[a("li",[t._v("标记化算法，进行元素状态的标记")]),a("li",[t._v("dom 树构建")])])]),a("li",[t._v("CSS parser --\x3e Style Tree\n"),a("ul",[a("li",[t._v("解析 css 代码，生成样式树")])])]),a("li",[t._v("attachment --\x3e Render Tree\n"),a("ul",[a("li",[t._v("结合 dom树 与 style树，生成渲染树")])])]),a("li",[t._v("layout: 布局")]),a("li",[t._v("GPU painting: 像素绘制页面")])])])]),a("h3",{attrs:{id:"重绘与回流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重绘与回流","aria-hidden":"true"}},[t._v("#")]),t._v(" 重绘与回流")]),a("p",[t._v("当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。")]),a("ul",[a("li",[a("strong",[t._v("重绘(repaint)")]),t._v(": 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少")]),a("li",[a("strong",[t._v("回流(reflow)")]),t._v(": 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:\n"),a("ul",[a("li",[t._v("页面初次渲染")]),a("li",[t._v("浏览器窗口大小改变")]),a("li",[t._v("元素尺寸、位置、内容发生改变")]),a("li",[t._v("元素字体大小变化")]),a("li",[t._v("添加或者删除可见的 dom 元素")]),a("li",[t._v("激活 CSS 伪类（例如：:hover）")]),a("li",[t._v("查询某些属性或调用某些方法\n"),a("ul",[a("li",[t._v("clientWidth、clientHeight、clientTop、clientLeft")]),a("li",[t._v("offsetWidth、offsetHeight、offsetTop、offsetLeft")]),a("li",[t._v("scrollWidth、scrollHeight、scrollTop、scrollLeft")]),a("li",[t._v("getComputedStyle()")]),a("li",[t._v("getBoundingClientRect()")]),a("li",[t._v("scrollTo()")])])])])])]),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("注意")]),a("p",[t._v("回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。")])]),a("p",[t._v("最佳实践:")]),a("ul",[a("li",[t._v("css\n"),a("ul",[a("li",[t._v("避免使用table布局")]),a("li",[t._v("将动画效果应用到position属性为absolute或fixed的元素上")])])]),a("li",[t._v("javascript\n"),a("ul",[a("li",[t._v("避免频繁操作样式，可汇总后统一 一次修改")]),a("li",[t._v("尽量使用class进行样式修改")]),a("li",[t._v("减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入")]),a("li",[t._v("极限优化时，修改样式可将其display: none后修改")]),a("li",[t._v("避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 变量存住")])])])]),a("h3",{attrs:{id:"存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储","aria-hidden":"true"}},[t._v("#")]),t._v(" 存储")]),a("p",[t._v("我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。")]),a("ul",[a("li",[t._v("短暂性的时候，我们只需要将数据存在内存中，只在运行时可用")]),a("li",[t._v("持久性存储，可以分为 浏览器端 与 服务器端\n"),a("ul",[a("li",[t._v("浏览器\n"),a("ul",[a("li",[a("code",[t._v("cookie")]),t._v(": 通常用于存储用户身份，登录状态等\n"),a("ul",[a("li",[t._v("http 中自动携带， 体积上限为 4K， 可自行设置过期时间")])])]),a("li",[a("code",[t._v("localStorage / sessionStorage")]),t._v(": 长久储存/窗口关闭删除， 体积限制为 4~5M")]),a("li",[a("code",[t._v("indexDB")])])])]),a("li",[t._v("服务器\n"),a("ul",[a("li",[t._v("分布式缓存 redis")]),a("li",[t._v("数据库")])])])])])]),a("h3",{attrs:{id:"web-worker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web-worker","aria-hidden":"true"}},[t._v("#")]),t._v(" Web Worker")]),a("p",[t._v("现代浏览器为JavaScript创造的 多线程环境。可以新建并将部分任务分配到worker线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信\n"),a("strong",[t._v("基本用法:")])]),a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{attrs:{class:"token comment"}},[t._v("// 创建 worker")]),t._v("\n"),a("span",{attrs:{class:"token keyword"}},[t._v("const")]),t._v(" worker "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{attrs:{class:"token class-name"}},[t._v("Worker")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token string"}},[t._v("'work.js'")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{attrs:{class:"token comment"}},[t._v("// 向主进程推送消息")]),t._v("\nworker"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("postMessage")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token string"}},[t._v("'Hello World'")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{attrs:{class:"token comment"}},[t._v("// 监听主进程来的消息")]),t._v("\nworker"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function-variable function"}},[t._v("onmessage")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("event"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{attrs:{class:"token function"}},[t._v("log")]),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token string"}},[t._v("'Received message '")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("+")]),t._v(" event"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data"),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])]),a("p",[a("strong",[t._v("限制:")])]),a("ul",[a("li",[t._v("同源限制")]),a("li",[t._v("无法使用 document / window / alert / confirm")]),a("li",[t._v("无法加载本地资源")])]),a("h3",{attrs:{id:"v8垃圾回收机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8垃圾回收机制","aria-hidden":"true"}},[t._v("#")]),t._v(" V8垃圾回收机制")]),a("p",[t._v("垃圾回收: 将内存中不再使用的数据进行清理，释放出内存空间。V8 将内存分成 新生代空间 和 老生代空间。")]),a("ul",[a("li",[t._v("新生代空间\n"),a("ul",[a("li",[t._v("又分成两个空间: from 空间 与 to 空间")]),a("li",[t._v("Scavenge GC算法: 当 from 空间被占满时，启动 GC 算法\n"),a("ul",[a("li",[t._v("存活的对象从 from space 转移到 to space")]),a("li",[t._v("清空 from space")]),a("li",[t._v("from space 与 to space 互换")]),a("li",[t._v("完成一次新生代GC")])])])])]),a("li",[a("strong",[t._v("老生代空间")]),t._v(": 用于存活时间较长的对象\n"),a("ul",[a("li",[t._v("从 新生代空间 转移到 老生代空间 的条件\n"),a("ul",[a("li",[t._v("经历过一次以上 Scavenge GC 的对象")]),a("li",[t._v("当 to space 体积超过25%")])])]),a("li",[a("strong",[t._v("标记清除算法")]),t._v(": 标记存活的对象，未被标记的则被释放\n"),a("ul",[a("li",[t._v("增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能")]),a("li",[t._v("并发标记(最新技术): 不阻塞 js 执行")])])]),a("li",[a("strong",[t._v("压缩算法")]),t._v(": 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决"),a("strong",[t._v("内存的碎片化")])])])])]),a("h3",{attrs:{id:"内存泄露"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存泄露","aria-hidden":"true"}},[t._v("#")]),t._v(" 内存泄露")]),a("ul",[a("li",[t._v("意外的全局变量: 无法被回收")]),a("li",[t._v("定时器: 未被正确关闭，导致所引用的外部变量无法被释放")]),a("li",[t._v("事件监听: 没有正确销毁 (低版本浏览器可能出现)")]),a("li",[t._v("闭包: 会导致父级中的变量无法被释放")]),a("li",[t._v("dom 引用: dom 元素被删除时，内存中的引用未被正确清空")])])])}],!1,null,null,null);s.default=e.exports}}]);