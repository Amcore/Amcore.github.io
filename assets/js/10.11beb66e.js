(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{179:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"content"},[a("h3",{attrs:{id:"浏览器的渲染过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的渲染过程","aria-hidden":"true"}},[t._v("#")]),t._v(" 浏览器的渲染过程")]),t._v(" "),a("ul",[a("li",[t._v("解析HTML，生成DOM树，解析CSS，生成CSSOM树")]),t._v(" "),a("li",[t._v("将DOM树和CSSOM树结合，生成渲染树(Render Tree)")]),t._v(" "),a("li",[t._v("Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）")]),t._v(" "),a("li",[t._v("Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素")]),t._v(" "),a("li",[t._v("Display:将像素发送给GPU，展示在页面上")])]),t._v(" "),a("h4",{attrs:{id:"生成渲染树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生成渲染树","aria-hidden":"true"}},[t._v("#")]),t._v(" 生成渲染树")]),t._v(" "),a("p",[t._v("为了构建渲染树，浏览器主要完成了以下工作：")]),t._v(" "),a("ul",[a("li",[t._v("从DOM树的根节点开始遍历每个可见节点。")]),t._v(" "),a("li",[t._v("对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。")]),t._v(" "),a("li",[t._v("根据每个可见节点以及其对应的样式，组合生成渲染树。")])]),t._v(" "),a("p",[t._v("第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：")]),t._v(" "),a("ul",[a("li",[t._v("一些不会渲染输出的节点，比如script、meta、link等。")]),t._v(" "),a("li",[t._v("一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有     display:none的节点才不会显示在渲染树上。")])]),t._v(" "),a("p",[t._v("从上面的例子来讲，我们可以看到span标签的样式有一个display:none，因此，它最终并没有在渲染树上。")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),a("p",[t._v("渲染树只包含可见的节点")])]),t._v(" "),a("h3",{attrs:{id:"回流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回流","aria-hidden":"true"}},[t._v("#")]),t._v(" 回流")]),t._v(" "),a("p",[t._v("前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。")]),t._v(" "),a("h3",{attrs:{id:"重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重绘","aria-hidden":"true"}},[t._v("#")]),t._v(" 重绘")]),t._v(" "),a("p",[t._v("最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。")]),t._v(" "),a("h3",{attrs:{id:"何时发生回流重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#何时发生回流重绘","aria-hidden":"true"}},[t._v("#")]),t._v(" 何时发生回流重绘")]),t._v(" "),a("p",[t._v("回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：\n添加或删除可见的DOM元素")]),t._v(" "),a("ul",[a("li",[t._v("元素的位置发生变化")]),t._v(" "),a("li",[t._v("元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）")]),t._v(" "),a("li",[t._v("内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。")]),t._v(" "),a("li",[t._v("页面一开始渲染的时候（这肯定避免不了）")]),t._v(" "),a("li",[t._v("浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）")])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("注意：回流一定会触发重绘，而重绘不一定会回流")]),t._v(" "),a("p",[t._v("根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。")])]),t._v(" "),a("h3",{attrs:{id:"浏览器的优化机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的优化机制","aria-hidden":"true"}},[t._v("#")]),t._v(" 浏览器的优化机制")]),t._v(" "),a("p",[t._v("现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("offsetTop、offsetLeft、offsetWidth、offsetHeight")])]),t._v(" "),a("li",[a("code",[t._v("scrollTop、scrollLeft、scrollWidth、scrollHeight")])]),t._v(" "),a("li",[a("code",[t._v("clientTop、clientLeft、clientWidth、clientHeight")])]),t._v(" "),a("li",[a("code",[t._v("getComputedStyle()")])]),t._v(" "),a("li",[a("code",[t._v("getBoundingClientRect")])])]),t._v(" "),a("p",[t._v("以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，"),a("strong",[t._v("最好避免使用上面列出的属性，他们都会刷新渲染队列。")]),t._v("\n如果要使用它们，最好将值缓存起来")]),t._v(" "),a("h3",{attrs:{id:"减少回流和重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#减少回流和重绘","aria-hidden":"true"}},[t._v("#")]),t._v(" 减少回流和重绘")]),t._v(" "),a("h4",{attrs:{id:"最小化重绘和重排"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最小化重绘和重排","aria-hidden":"true"}},[t._v("#")]),t._v(" 最小化重绘和重排")]),t._v(" "),a("p",[t._v("由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" el "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'test'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("padding "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'5px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("borderLeft "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'1px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("borderRight "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。")]),t._v(" "),a("ul",[a("li",[t._v("使用cssText")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" el "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'test'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("cssText "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'border-left: 1px; border-right: 2px; padding: 5px;'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("ul",[a("li",[t._v("修改CSS的class")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" el "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'test'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nel"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("className "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("' active'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("h4",{attrs:{id:"批量修改dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#批量修改dom","aria-hidden":"true"}},[t._v("#")]),t._v(" 批量修改DOM")]),t._v(" "),a("p",[t._v("当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：")]),t._v(" "),a("ul",[a("li",[t._v("使元素脱离文档流")]),t._v(" "),a("li",[t._v("对其进行多次修改")]),t._v(" "),a("li",[t._v("将元素带回到文档中。\n该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流重绘，因为它已经不在渲染树了。")])]),t._v(" "),a("p",[t._v("有三种方式可以让DOM脱离文档流：")]),t._v(" "),a("ul",[a("li",[t._v("隐藏元素，应用修改，重新显示")]),t._v(" "),a("li",[t._v("使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。")]),t._v(" "),a("li",[t._v("将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。")])]),t._v(" "),a("h4",{attrs:{id:"避免触发同步布局事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#避免触发同步布局事件","aria-hidden":"true"}},[t._v("#")]),t._v(" 避免触发同步布局事件")]),t._v(" "),a("p",[t._v("当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("initP")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" paragraphs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        paragraphs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("width "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" box"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetWidth "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为:")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" width "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" box"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("offsetWidth"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("initP")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" paragraphs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        paragraphs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("width "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" width "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'px'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("通过这样的优化，性能能提高不少呢。")]),t._v(" "),a("h3",{attrs:{id:"对于复杂动画效果-使用绝对定位让其脱离文档流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对于复杂动画效果-使用绝对定位让其脱离文档流","aria-hidden":"true"}},[t._v("#")]),t._v(" 对于复杂动画效果,使用绝对定位让其脱离文档流")]),t._v(" "),a("h4",{attrs:{id:"css3硬件加速（gpu加速）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css3硬件加速（gpu加速）","aria-hidden":"true"}},[t._v("#")]),t._v(" css3硬件加速（GPU加速）")]),t._v(" "),a("p",[t._v("比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("划重点：")]),t._v(" "),a("ol",[a("li",[t._v("使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。")]),t._v(" "),a("li",[t._v("对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。")])])]),t._v(" "),a("p",[t._v("如何使用")]),t._v(" "),a("ul",[a("li",[t._v("transform")]),t._v(" "),a("li",[t._v("opacity")]),t._v(" "),a("li",[t._v("filters")]),t._v(" "),a("li",[t._v("Will-change")])]),t._v(" "),a("p",[a("strong",[t._v("重点")])]),t._v(" "),a("ul",[a("li",[t._v("使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘")]),t._v(" "),a("li",[t._v("对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。")])]),t._v(" "),a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("css3硬件加速的坑")]),t._v(" "),a("p",[t._v("如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。\n在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。")])])])}],!1,null,null,null);s.default=e.exports}}]);